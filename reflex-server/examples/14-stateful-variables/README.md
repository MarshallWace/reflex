# Reflex CLI Example: Stateful variables

This example demonstrates how to work with stateful variables within Reflex.

The conceptual model of Reflex is much better suited to a stream-processing approach rather than relying on imperative mutations, so when writing Reflex programs it is recommended to avoid using stateful variables as far as possible. Occasionally though, state variables are necessary in order to imperatively force a state update or perform a one-off action.

State variables are identified by a *uid token*. The uid token is a symbol that determines the unique in-memory 'slot' that is used to store the current value of the variable.

Typically, uid tokens are generated by invoking the `hash(...)` helper function on a set of uniqueness-determining values. The state variable uid token namespace is global: any two state variables with the same uid token will share the same underlying value. One way to minimize accidental collisions is to always use namespaced hashes for variable uid tokens, as seen in this example.

Given a state variable uid token, the following library helpers can be used to manipulate the value in that memory slot:

- `get(uid, defaultValue)` - Get the value of the state variable (falling back to the given default value if the variable has not yet been set)
- `set(uid, value, token)` - Update the value of the state variable, returning the updated value
- `increment(uid, token)` - Increment the value of a numeric state variable, returning the updated value
- `decrement(uid, token)` - Decrement the value of a numeric state variable, returning the updated value

The methods that mutate the state variable all accept a `token` argument: this is an idempotency token that uniquely identifies the mutation and ensures that it will be processed as a standalone operation.

> For convenience, there also exists a shorthand `variable(uid)` helper that returns a 2-item array containing `get` and `set` methods respectively, both with their initial `uid` arguments pre-bound to the provided uid token.

The example also demonstrates how to use the `sequence(expression, callback)` helper for expressions that must be evaluated in a specific order. The standard Reflex behavior is to attempt to execute side-effects concurrently where possible - this is usually desirable, however there are certain occasions where the application logic needs to enforce a linear sequence of stateful events. The `sequence` helper is provided to deal with these situations.

The `sequence(expression, callback)` function accepts an expression to evaluate as its first argument, and the second argument is a callback function whose argument will be the evaluated expression. The overall return value of the `sequence()` call will be the value returned by the callback function.

The `log(expression, ...args)` helper is used to log debug messages to the console. This will log a line to `stdout` containing the `expression` argument followed by each of the `args`, and will return the `expression`. Every time the `expression` (or one of the other arguments) changes, a new line will be logged, which can be helpful for observing how an expression's value changes over time. Note that the `expression` is logged *before* having any of its effect dependencies resolved, which can be useful in debugging side-effects - in this example however, a `sequence()` operation is used to ensure the expression that is logged has had its effects fully resolved before the resulting value is logged.

## Source files

- [`index.js`](./index.js)

## Running the example

```shell
$ reflex-server --port 8080 ./index.js
```
> This will serve a GraphQL playground at http://localhost:8080/

## Example query

```
mutation {
  operation1: reset(value: 3)
  operation2: increment
}
```

## Example response

```
{
  "data": {
    "operation1": 3,
    "operation2": 4
  }
}
```
